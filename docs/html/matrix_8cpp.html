<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lab_1: C:/Users/User/Desktop/AIP/lab1/lab1/linalg/source/matrix.cpp File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lab_1<span id="projectnumber">&#160;0.1.1</span>
   </div>
   <div id="projectbrief">Matrix Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',false);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_f5d8d344b3ed29011483c4171cb0b839.html">AIP</a></li><li class="navelem"><a class="el" href="dir_6d539f09534ddb38e8b7288e29ee6351.html">lab1</a></li><li class="navelem"><a class="el" href="dir_625983030341ff4074442a3bd808c3a7.html">lab1</a></li><li class="navelem"><a class="el" href="dir_916a2677f09e3f5b41b6dea1c1e5b893.html">linalg</a></li><li class="navelem"><a class="el" href="dir_76f57785d218d2b6a041514812147503.html">source</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">matrix.cpp File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>C++ library for working with matrices.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;matrix.h&quot;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;iomanip&gt;</code><br />
<code>#include &lt;iostream&gt;</code><br />
<code>#include &lt;sstream&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adb3b03475c9c46a4653996c77ebb775d" id="r_adb3b03475c9c46a4653996c77ebb775d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb3b03475c9c46a4653996c77ebb775d">linalg::max_length_first</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m, const std::ostream &amp;out)</td></tr>
<tr class="memdesc:adb3b03475c9c46a4653996c77ebb775d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of digits in the first column of the matrix.  <br /></td></tr>
<tr class="separator:adb3b03475c9c46a4653996c77ebb775d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab535a759db458a52cf08319df2feaf24" id="r_ab535a759db458a52cf08319df2feaf24"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab535a759db458a52cf08319df2feaf24">linalg::max_length_not_first</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m, const std::ostream &amp;out)</td></tr>
<tr class="memdesc:ab535a759db458a52cf08319df2feaf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the maximum number of digits in the second and later columns of the matrix.  <br /></td></tr>
<tr class="separator:ab535a759db458a52cf08319df2feaf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f21c44eb65edc7d67a4cbe8fca81bab" id="r_a4f21c44eb65edc7d67a4cbe8fca81bab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f21c44eb65edc7d67a4cbe8fca81bab">linalg::equal</a> (const double &amp;a, const double &amp;b)</td></tr>
<tr class="memdesc:a4f21c44eb65edc7d67a4cbe8fca81bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compares two double values for equality.  <br /></td></tr>
<tr class="separator:a4f21c44eb65edc7d67a4cbe8fca81bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb9d74c6dccb8afff36c62b5425e32c" id="r_aadb9d74c6dccb8afff36c62b5425e32c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#aadb9d74c6dccb8afff36c62b5425e32c">linalg::operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:aadb9d74c6dccb8afff36c62b5425e32c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints the matrix to the output stream.  <br /></td></tr>
<tr class="separator:aadb9d74c6dccb8afff36c62b5425e32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad936f452b731f1c613aa6baa5c7d3a03" id="r_ad936f452b731f1c613aa6baa5c7d3a03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#ad936f452b731f1c613aa6baa5c7d3a03">linalg::operator+</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m1, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:ad936f452b731f1c613aa6baa5c7d3a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sums two matrices.  <br /></td></tr>
<tr class="separator:ad936f452b731f1c613aa6baa5c7d3a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34801dee657fd6ced9b1daf1b5b3fe32" id="r_a34801dee657fd6ced9b1daf1b5b3fe32"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a34801dee657fd6ced9b1daf1b5b3fe32">linalg::operator*</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m, const double c) noexcept</td></tr>
<tr class="memdesc:a34801dee657fd6ced9b1daf1b5b3fe32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a scalar.  <br /></td></tr>
<tr class="separator:a34801dee657fd6ced9b1daf1b5b3fe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb35b959fbb255e91cac13c10944ca4d" id="r_abb35b959fbb255e91cac13c10944ca4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#abb35b959fbb255e91cac13c10944ca4d">linalg::operator*</a> (const double c, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:abb35b959fbb255e91cac13c10944ca4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a scalar.  <br /></td></tr>
<tr class="separator:abb35b959fbb255e91cac13c10944ca4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47196e27e527f1260f3fd5368b595f02" id="r_a47196e27e527f1260f3fd5368b595f02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a47196e27e527f1260f3fd5368b595f02">linalg::operator-</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m1, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a47196e27e527f1260f3fd5368b595f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one matrix from another.  <br /></td></tr>
<tr class="separator:a47196e27e527f1260f3fd5368b595f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2771c91bb7e83b307707a08fb7d1229" id="r_ae2771c91bb7e83b307707a08fb7d1229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#ae2771c91bb7e83b307707a08fb7d1229">linalg::operator*</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m1, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:ae2771c91bb7e83b307707a08fb7d1229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiply two matrices.  <br /></td></tr>
<tr class="separator:ae2771c91bb7e83b307707a08fb7d1229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa973d76d1cb38c7aea2ae0cf216f61" id="r_afaa973d76d1cb38c7aea2ae0cf216f61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#afaa973d76d1cb38c7aea2ae0cf216f61">linalg::operator==</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m1, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:afaa973d76d1cb38c7aea2ae0cf216f61"><td class="mdescLeft">&#160;</td><td class="mdescRight">delat  <br /></td></tr>
<tr class="separator:afaa973d76d1cb38c7aea2ae0cf216f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ba8dbb57cc70472b95a189f52c3bf" id="r_add5ba8dbb57cc70472b95a189f52c3bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#add5ba8dbb57cc70472b95a189f52c3bf">linalg::operator!=</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m1, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:add5ba8dbb57cc70472b95a189f52c3bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if two matrices are not equal.  <br /></td></tr>
<tr class="separator:add5ba8dbb57cc70472b95a189f52c3bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8459a29629965f8ed7870362a9979d28" id="r_a8459a29629965f8ed7870362a9979d28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a8459a29629965f8ed7870362a9979d28">linalg::concatenate</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m1, const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m2)</td></tr>
<tr class="memdesc:a8459a29629965f8ed7870362a9979d28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenates two matrices horizontally.  <br /></td></tr>
<tr class="separator:a8459a29629965f8ed7870362a9979d28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ef85d8bc7bdb8366f2124b8b67be44e" id="r_a1ef85d8bc7bdb8366f2124b8b67be44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a1ef85d8bc7bdb8366f2124b8b67be44e">linalg::transpose</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a1ef85d8bc7bdb8366f2124b8b67be44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transposed matrix.  <br /></td></tr>
<tr class="separator:a1ef85d8bc7bdb8366f2124b8b67be44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3a742ea83546ab3c758a7414f10e07" id="r_a4f3a742ea83546ab3c758a7414f10e07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a4f3a742ea83546ab3c758a7414f10e07">linalg::uni</a> (size_t n)</td></tr>
<tr class="memdesc:a4f3a742ea83546ab3c758a7414f10e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a unit matrix of size n x n.  <br /></td></tr>
<tr class="separator:a4f3a742ea83546ab3c758a7414f10e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2eebc0ba98ec044e7e4826fa3270a65" id="r_ac2eebc0ba98ec044e7e4826fa3270a65"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#ac2eebc0ba98ec044e7e4826fa3270a65">linalg::invert_old</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:ac2eebc0ba98ec044e7e4826fa3270a65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the inverse matrix.  <br /></td></tr>
<tr class="separator:ac2eebc0ba98ec044e7e4826fa3270a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ce7a0ce23b1b1556d633a7c45abef1" id="r_a35ce7a0ce23b1b1556d633a7c45abef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a35ce7a0ce23b1b1556d633a7c45abef1">linalg::invert</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:a35ce7a0ce23b1b1556d633a7c45abef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts a square matrix.  <br /></td></tr>
<tr class="separator:a35ce7a0ce23b1b1556d633a7c45abef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce32c7820e27bb544526c18ff3bacf8" id="r_a1ce32c7820e27bb544526c18ff3bacf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="matrix_8h.html#a1ce32c7820e27bb544526c18ff3bacf8">linalg::power</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m, int p)</td></tr>
<tr class="memdesc:a1ce32c7820e27bb544526c18ff3bacf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the power of the matrix.  <br /></td></tr>
<tr class="separator:a1ce32c7820e27bb544526c18ff3bacf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:afe01386a82fedc016455a43c20280a97" id="r_afe01386a82fedc016455a43c20280a97"><td class="memItemLeft" align="right" valign="top"><a id="afe01386a82fedc016455a43c20280a97" name="afe01386a82fedc016455a43c20280a97"></a>
const double&#160;</td><td class="memItemRight" valign="bottom"><b>EPS</b> = 1e-10</td></tr>
<tr class="separator:afe01386a82fedc016455a43c20280a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C++ library for working with matrices. </p>
<dl class="section version"><dt>Version</dt><dd>0.1.0 </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2024-10-21 </dd></dl>
<dl class="section author"><dt>Authors</dt><dd>vmarkov20 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8459a29629965f8ed7870362a9979d28" name="a8459a29629965f8ed7870362a9979d28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8459a29629965f8ed7870362a9979d28">&#9670;&#160;</a></span>concatenate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::concatenate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenates two matrices horizontally. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>the first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>the second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the number of rows of matrices are not equal</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the resulting matrix</dd></dl>
<p>If both matrices are empty, the result is an empty matrix. If only one of the matrices is empty, the result is the other matrix. </p>

</div>
</div>
<a id="a4f21c44eb65edc7d67a4cbe8fca81bab" name="a4f21c44eb65edc7d67a4cbe8fca81bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f21c44eb65edc7d67a4cbe8fca81bab">&#9670;&#160;</a></span>equal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool linalg::equal </td>
          <td>(</td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compares two double values for equality. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>The first number </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>The second number</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the difference between the two numbers is less than EPS</dd></dl>
<p>EPS is a small value used to compare floating point numbers. It is set to 1e-10 </p>

</div>
</div>
<a id="a35ce7a0ce23b1b1556d633a7c45abef1" name="a35ce7a0ce23b1b1556d633a7c45abef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35ce7a0ce23b1b1556d633a7c45abef1">&#9670;&#160;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts a square matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to be inverted. Must be square and non-degenerate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the inverse of the input matrix. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is degenerate, empty, or not square.</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>This function takes a square matrix and returns its inverse. If the matrix is degenerate (i.e., its determinant is zero), an exception is thrown. Similarly, if the matrix is empty or not square, the function throws an exception.</li>
</ul>
<p>The function internally uses Gaussian elimination to compute the inverse. It concatenates the input matrix with an identity matrix, applies Gaussian elimination, and extracts the inverse matrix from the result. </p>

</div>
</div>
<a id="ac2eebc0ba98ec044e7e4826fa3270a65" name="ac2eebc0ba98ec044e7e4826fa3270a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2eebc0ba98ec044e7e4826fa3270a65">&#9670;&#160;</a></span>invert_old()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Matrix linalg::invert_old </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the inverse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>Input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is empty, not square, or determinant is zero</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated</a></b></dt><dd>This implementation uses an older method of matrix inversion. Consider using the new method <code>invert</code> for better performance.</dd></dl>
<p>This function computes the inverse of a given square matrix. It first checks if the matrix is square and has a non-zero determinant. If these conditions are met, it calculates the inverse using the formula involving minors, cofactors, and the determinant. </p>

</div>
</div>
<a id="adb3b03475c9c46a4653996c77ebb775d" name="adb3b03475c9c46a4653996c77ebb775d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3b03475c9c46a4653996c77ebb775d">&#9670;&#160;</a></span>max_length_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t linalg::max_length_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of digits in the first column of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>The output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of digits</dd></dl>
<p>The function iterates over all elements of the first column of the matrix and measures the length of each element when it is printed to the given output stream. The maximum length of all elements is returned as the result. </p>

</div>
</div>
<a id="ab535a759db458a52cf08319df2feaf24" name="ab535a759db458a52cf08319df2feaf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab535a759db458a52cf08319df2feaf24">&#9670;&#160;</a></span>max_length_not_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t linalg::max_length_not_first </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the maximum number of digits in the second and later columns of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>The output stream</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of digits</dd></dl>
<p>The function iterates over all elements of the matrix except the first column and measures the length of each element when it is printed to the given output stream. The maximum length of all elements is returned as the result. </p>

</div>
</div>
<a id="add5ba8dbb57cc70472b95a189f52c3bf" name="add5ba8dbb57cc70472b95a189f52c3bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add5ba8dbb57cc70472b95a189f52c3bf">&#9670;&#160;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool linalg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if two matrices are not equal. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>The first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>The second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the matrices are not equal, false otherwise</dd></dl>
<p>The function checks if the two matrices are not equal. This function is the opposite of the operator==. If the operator== returns false, this function returns true and vice versa. </p>

</div>
</div>
<a id="abb35b959fbb255e91cac13c10944ca4d" name="abb35b959fbb255e91cac13c10944ca4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb35b959fbb255e91cac13c10944ca4d">&#9670;&#160;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::operator* </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The scalar to scale by </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled matrix</dd></dl>
<p>This function multiplies the matrix m by the scalar c. It is equivalent to calling m * c. </p>

</div>
</div>
<a id="a34801dee657fd6ced9b1daf1b5b3fe32" name="a34801dee657fd6ced9b1daf1b5b3fe32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34801dee657fd6ced9b1daf1b5b3fe32">&#9670;&#160;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The scalar to scale by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled matrix</dd></dl>
<p>The result is a new matrix that is the result of scaling the input matrix by the given scalar. The original matrix is not modified. </p>

</div>
</div>
<a id="ae2771c91bb7e83b307707a08fb7d1229" name="ae2771c91bb7e83b307707a08fb7d1229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2771c91bb7e83b307707a08fb7d1229">&#9670;&#160;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiply two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>The first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>The second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the multiplication</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the number of columns of the first matrix is not equal to the number of rows of the second matrix</td></tr>
  </table>
  </dd>
</dl>
<p>The function multiplies two matrices. The function first checks if the number of columns of the first matrix is equal to the number of rows of the second matrix. If the sizes are different, the function throws an exception. Otherwise, the function multiplies the matrices and returns the result. </p>

</div>
</div>
<a id="ad936f452b731f1c613aa6baa5c7d3a03" name="ad936f452b731f1c613aa6baa5c7d3a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad936f452b731f1c613aa6baa5c7d3a03">&#9670;&#160;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sums two matrices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>The first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>The second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrices have different sizes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The sum of the two matrices</dd></dl>
<p>This function adds two matrices element-wise. The result is a new matrix, the original matrices are unchanged. </p>

</div>
</div>
<a id="a47196e27e527f1260f3fd5368b595f02" name="a47196e27e527f1260f3fd5368b595f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47196e27e527f1260f3fd5368b595f02">&#9670;&#160;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts one matrix from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>The first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>The second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the sizes of the matrices are not equal</td></tr>
  </table>
  </dd>
</dl>
<p>The function subtracts the second matrix from the first matrix and returns the resulting matrix. It first checks if the sizes of the matrices are equal. If they are not, it throws an exception. </p>

</div>
</div>
<a id="aadb9d74c6dccb8afff36c62b5425e32c" name="aadb9d74c6dccb8afff36c62b5425e32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb9d74c6dccb8afff36c62b5425e32c">&#9670;&#160;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; linalg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints the matrix to the output stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">out</td><td>The output stream </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to print</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The output stream after printing the matrix</dd></dl>
<p>This function prints the matrix in a human-readable format to the output stream. It first checks if the matrix is empty and prints "|empty|". Otherwise, it prints the matrix row-by-row, with elements separated by spaces and rows separated by newline characters. The elements are formatted according to the settings of the output stream. If an element is equal to zero, it is printed as "0". The width of the first element is determined by the maximum number of digits in the first column, and the width of other elements is determined by the maximum number of digits in the other columns. The elements are aligned to the right. </p>

</div>
</div>
<a id="afaa973d76d1cb38c7aea2ae0cf216f61" name="afaa973d76d1cb38c7aea2ae0cf216f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa973d76d1cb38c7aea2ae0cf216f61">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool linalg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>delat </p>
<p>Checks if two matrices are equal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m1</td><td>The first matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">m2</td><td>The second matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the matrices are equal, false otherwise</dd></dl>
<p>The function checks if the two matrices are equal. If the number of rows or columns of the matrices is different, the function returns false. Otherwise, the function compares each element of the matrices. If any of the elements are not equal, the function returns false. If all the elements are equal, the function returns true. </p>

</div>
</div>
<a id="a1ce32c7820e27bb544526c18ff3bacf8" name="a1ce32c7820e27bb544526c18ff3bacf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce32c7820e27bb544526c18ff3bacf8">&#9670;&#160;</a></span>power()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::power </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>p</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the power of the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Input matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">deg</td><td>Degree of the power </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the power of the matrix </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is empty or the dimensions are different</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the power of a given matrix. It first checks if the matrix is empty or if the dimensions are different, and if so, throws an exception. If the degree of the power is 0, it returns the unit matrix. If the degree is negative, it returns the inverse of the matrix. Otherwise, it multiplies the matrix by itself deg times.</p>
<p>Calculates the power of the matrix</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to be raised to a power. Must be square. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>The exponent. Can be a positive or negative integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new matrix that is the result of raising the input matrix to the power <code>p</code>. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is non-invertible when <code>p</code> is negative.</td></tr>
  </table>
  </dd>
</dl>
<p>This function raises a matrix <code>m</code> to an integer power <code>p</code>. If <code>p</code> is zero, the function returns the identity matrix. For positive powers, the matrix is multiplied by itself <code>p</code> times. For negative powers, the function returns the inverse of the matrix raised to the absolute value of <code>p</code>. </p>

</div>
</div>
<a id="a1ef85d8bc7bdb8366f2124b8b67be44e" name="a1ef85d8bc7bdb8366f2124b8b67be44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ef85d8bc7bdb8366f2124b8b67be44e">&#9670;&#160;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the transposed matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transposed matrix</dd></dl>
<p>The transposed matrix is a matrix that has the same elements as the original one, but the elements are rearranged so that the rows of the original matrix become the columns of the transposed matrix, and the columns of the original matrix become the rows of the transposed matrix. </p>

</div>
</div>
<a id="a4f3a742ea83546ab3c758a7414f10e07" name="a4f3a742ea83546ab3c758a7414f10e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f3a742ea83546ab3c758a7414f10e07">&#9670;&#160;</a></span>uni()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Matrix linalg::uni </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a unit matrix of size n x n. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>The size of the unit matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A unit matrix with ones on the diagonal and zeros elsewhere</dd></dl>
<p>A unit matrix, also known as an identity matrix, is a square matrix in which all the elements of the principal diagonal are ones and all other elements are zeros. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
