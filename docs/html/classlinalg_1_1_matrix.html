<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lab1: linalg::Matrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lab1<span id="projectnumber">&#160;0.1.0</span>
   </div>
   <div id="projectbrief">Matrix library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>linalg</b></li><li class="navelem"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a></li>  </ul>
</div>
</div><!-- top -->
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classlinalg_1_1_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">linalg::Matrix Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f96b87b6a3dd8f8f4d11b6260174f7b" id="r_a8f96b87b6a3dd8f8f4d11b6260174f7b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f96b87b6a3dd8f8f4d11b6260174f7b">Matrix</a> (size_t rows)</td></tr>
<tr class="memdesc:a8f96b87b6a3dd8f8f4d11b6260174f7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix with a given number of rows.  <br /></td></tr>
<tr class="separator:a8f96b87b6a3dd8f8f4d11b6260174f7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe4238c0cdbe92486d28855d14c1dc3" id="r_aafe4238c0cdbe92486d28855d14c1dc3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafe4238c0cdbe92486d28855d14c1dc3">Matrix</a> (size_t rows, size_t columns)</td></tr>
<tr class="memdesc:aafe4238c0cdbe92486d28855d14c1dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix with a given number of rows and columns.  <br /></td></tr>
<tr class="separator:aafe4238c0cdbe92486d28855d14c1dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee85000792ec3b3c16fc9fc11d370d2" id="r_a3ee85000792ec3b3c16fc9fc11d370d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ee85000792ec3b3c16fc9fc11d370d2">Matrix</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m) noexcept</td></tr>
<tr class="memdesc:a3ee85000792ec3b3c16fc9fc11d370d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a3ee85000792ec3b3c16fc9fc11d370d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5f18bb9d7d7db8d57444944a86fcccb" id="r_aa5f18bb9d7d7db8d57444944a86fcccb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5f18bb9d7d7db8d57444944a86fcccb">Matrix</a> (<a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&amp;m) noexcept</td></tr>
<tr class="memdesc:aa5f18bb9d7d7db8d57444944a86fcccb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:aa5f18bb9d7d7db8d57444944a86fcccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e739f5444b5bcbf0084b7a0ce4732a" id="r_a11e739f5444b5bcbf0084b7a0ce4732a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11e739f5444b5bcbf0084b7a0ce4732a">Matrix</a> (std::initializer_list&lt; double &gt; lst) noexcept</td></tr>
<tr class="memdesc:a11e739f5444b5bcbf0084b7a0ce4732a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix from a list of doubles.  <br /></td></tr>
<tr class="separator:a11e739f5444b5bcbf0084b7a0ce4732a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44654bac3cc1ee24b3e3d0ac7ab37a43" id="r_a44654bac3cc1ee24b3e3d0ac7ab37a43"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44654bac3cc1ee24b3e3d0ac7ab37a43">Matrix</a> (std::initializer_list&lt; std::initializer_list&lt; double &gt; &gt; lst)</td></tr>
<tr class="memdesc:a44654bac3cc1ee24b3e3d0ac7ab37a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a matrix from a list of lists of doubles.  <br /></td></tr>
<tr class="separator:a44654bac3cc1ee24b3e3d0ac7ab37a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbf692071e2e0707384a8aa9a617d0c" id="r_a6fbf692071e2e0707384a8aa9a617d0c"><td class="memItemLeft" align="right" valign="top"><a id="a6fbf692071e2e0707384a8aa9a617d0c" name="a6fbf692071e2e0707384a8aa9a617d0c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>rows</b> () const noexcept</td></tr>
<tr class="separator:a6fbf692071e2e0707384a8aa9a617d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a596f0a141b8152bfcf1458ae12c54031" id="r_a596f0a141b8152bfcf1458ae12c54031"><td class="memItemLeft" align="right" valign="top"><a id="a596f0a141b8152bfcf1458ae12c54031" name="a596f0a141b8152bfcf1458ae12c54031"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>columns</b> () const noexcept</td></tr>
<tr class="separator:a596f0a141b8152bfcf1458ae12c54031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ecacc7e780228f66e7176718c61c37" id="r_a49ecacc7e780228f66e7176718c61c37"><td class="memItemLeft" align="right" valign="top"><a id="a49ecacc7e780228f66e7176718c61c37" name="a49ecacc7e780228f66e7176718c61c37"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>empty</b> () const noexcept</td></tr>
<tr class="separator:a49ecacc7e780228f66e7176718c61c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a390a3466d2e4131b3f8f4c71bdbdf6" id="r_a6a390a3466d2e4131b3f8f4c71bdbdf6"><td class="memItemLeft" align="right" valign="top"><a id="a6a390a3466d2e4131b3f8f4c71bdbdf6" name="a6a390a3466d2e4131b3f8f4c71bdbdf6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reshape</b> (size_t new_rows, size_t new_columns)</td></tr>
<tr class="separator:a6a390a3466d2e4131b3f8f4c71bdbdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8677399f619c7be88ba9e62ace30f3" id="r_a3f8677399f619c7be88ba9e62ace30f3"><td class="memItemLeft" align="right" valign="top">double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f8677399f619c7be88ba9e62ace30f3">operator()</a> (size_t row, size_t column)</td></tr>
<tr class="memdesc:a3f8677399f619c7be88ba9e62ace30f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the element at the specified position in the matrix.  <br /></td></tr>
<tr class="separator:a3f8677399f619c7be88ba9e62ace30f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b619458307295d080f3d77a98fe5f" id="r_a301b619458307295d080f3d77a98fe5f"><td class="memItemLeft" align="right" valign="top">const double &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a301b619458307295d080f3d77a98fe5f">operator()</a> (size_t row, size_t column) const</td></tr>
<tr class="memdesc:a301b619458307295d080f3d77a98fe5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accesses the element at the specified position in the matrix (const version)  <br /></td></tr>
<tr class="separator:a301b619458307295d080f3d77a98fe5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47851fafac86b6455efcfb3fba322ec3" id="r_a47851fafac86b6455efcfb3fba322ec3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47851fafac86b6455efcfb3fba322ec3">operator=</a> (<a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> m) noexcept</td></tr>
<tr class="memdesc:a47851fafac86b6455efcfb3fba322ec3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <br /></td></tr>
<tr class="separator:a47851fafac86b6455efcfb3fba322ec3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf33ca858d3b47ffd0adf964704427da" id="r_aaf33ca858d3b47ffd0adf964704427da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf33ca858d3b47ffd0adf964704427da">operator+=</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:aaf33ca858d3b47ffd0adf964704427da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds another matrix to the current matrix.  <br /></td></tr>
<tr class="separator:aaf33ca858d3b47ffd0adf964704427da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad68f42252b84c22242236d8c6c157b" id="r_aaad68f42252b84c22242236d8c6c157b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaad68f42252b84c22242236d8c6c157b">operator-=</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:aaad68f42252b84c22242236d8c6c157b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtracts one matrix from another.  <br /></td></tr>
<tr class="separator:aaad68f42252b84c22242236d8c6c157b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f26984333a74a464d6d31e5d6ef5d5" id="r_a63f26984333a74a464d6d31e5d6ef5d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63f26984333a74a464d6d31e5d6ef5d5">operator*=</a> (const double c) noexcept</td></tr>
<tr class="memdesc:a63f26984333a74a464d6d31e5d6ef5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by a scalar.  <br /></td></tr>
<tr class="separator:a63f26984333a74a464d6d31e5d6ef5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6cad550f4d7ab094197e1f060faa82e" id="r_ac6cad550f4d7ab094197e1f060faa82e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6cad550f4d7ab094197e1f060faa82e">operator*=</a> (const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;m)</td></tr>
<tr class="memdesc:ac6cad550f4d7ab094197e1f060faa82e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplies the matrix by another matrix.  <br /></td></tr>
<tr class="separator:ac6cad550f4d7ab094197e1f060faa82e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab397cae560fbd57d351232dff61d07b9" id="r_ab397cae560fbd57d351232dff61d07b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab397cae560fbd57d351232dff61d07b9">trace</a> () const</td></tr>
<tr class="memdesc:ab397cae560fbd57d351232dff61d07b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the trace of the matrix.  <br /></td></tr>
<tr class="separator:ab397cae560fbd57d351232dff61d07b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad230dd6657ebeac6eff624dc7d243849" id="r_ad230dd6657ebeac6eff624dc7d243849"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad230dd6657ebeac6eff624dc7d243849">norm</a> () const</td></tr>
<tr class="memdesc:ad230dd6657ebeac6eff624dc7d243849"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the norm of the matrix.  <br /></td></tr>
<tr class="separator:ad230dd6657ebeac6eff624dc7d243849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab100afe2f2b7159627b52e12213c1e8b" id="r_ab100afe2f2b7159627b52e12213c1e8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab100afe2f2b7159627b52e12213c1e8b">Gauss</a> (bool rref) const</td></tr>
<tr class="memdesc:ab100afe2f2b7159627b52e12213c1e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gaussian elimination.  <br /></td></tr>
<tr class="separator:ab100afe2f2b7159627b52e12213c1e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6c4310332522a4dd8390503b5be464" id="r_a5a6c4310332522a4dd8390503b5be464"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a6c4310332522a4dd8390503b5be464">det</a> () const</td></tr>
<tr class="memdesc:a5a6c4310332522a4dd8390503b5be464"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the determinant of the matrix.  <br /></td></tr>
<tr class="separator:a5a6c4310332522a4dd8390503b5be464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832a0695cdb27222279a019d70fb56c7" id="r_a832a0695cdb27222279a019d70fb56c7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a832a0695cdb27222279a019d70fb56c7">minor</a> (size_t rows, size_t columns) const</td></tr>
<tr class="memdesc:a832a0695cdb27222279a019d70fb56c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the minor of the matrix at the given position.  <br /></td></tr>
<tr class="separator:a832a0695cdb27222279a019d70fb56c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8f96b87b6a3dd8f8f4d11b6260174f7b" name="a8f96b87b6a3dd8f8f4d11b6260174f7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f96b87b6a3dd8f8f4d11b6260174f7b">&#9670;&#160;</a></span>Matrix() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rows</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix with a given number of rows. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The number of rows </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the number of rows is negative</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes a matrix with the specified number of rows. It allocates memory for the matrix elements and sets the internal row and column counters. The number of columns is set to 1. If the given number of rows is negative, an exception is thrown. </p>

</div>
</div>
<a id="aafe4238c0cdbe92486d28855d14c1dc3" name="aafe4238c0cdbe92486d28855d14c1dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe4238c0cdbe92486d28855d14c1dc3">&#9670;&#160;</a></span>Matrix() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>columns</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix with a given number of rows and columns. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The number of rows </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns</td><td>The number of columns </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the number of rows or columns is negative</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes a matrix with the specified number of rows and columns. It allocates memory for the matrix elements and sets the internal row and column counters. If the given number of rows or columns is negative, an exception is thrown. </p>

</div>
</div>
<a id="a3ee85000792ec3b3c16fc9fc11d370d2" name="a3ee85000792ec3b3c16fc9fc11d370d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee85000792ec3b3c16fc9fc11d370d2">&#9670;&#160;</a></span>Matrix() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">linalg::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to be copied</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor creates a new matrix object as a copy of the given matrix. It allocates memory for the matrix elements and copies the data from the source matrix. The constructor is marked as noexcept, indicating that no exceptions will be thrown during the copy operation. </p>

</div>
</div>
<a id="aa5f18bb9d7d7db8d57444944a86fcccb" name="aa5f18bb9d7d7db8d57444944a86fcccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5f18bb9d7d7db8d57444944a86fcccb">&#9670;&#160;</a></span>Matrix() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">linalg::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to be moved</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor is used to move the contents of another matrix to the current one. The contents of the other matrix are swapped with the contents of the current matrix. The move constructor is marked as noexcept, which means that no exceptions are thrown during the move operation. </p>

</div>
</div>
<a id="a11e739f5444b5bcbf0084b7a0ce4732a" name="a11e739f5444b5bcbf0084b7a0ce4732a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e739f5444b5bcbf0084b7a0ce4732a">&#9670;&#160;</a></span>Matrix() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">linalg::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; double &gt;</td>          <td class="paramname"><span class="paramname"><em>lst</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a matrix from a list of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>The list of doubles</td></tr>
  </table>
  </dd>
</dl>
<p>This constructor initializes a matrix with the number of rows equal to the size of the list and a single column. Each element of the list becomes an element in the matrix. The matrix is constructed in a way that each element of the list corresponds to a row in the matrix. </p>

</div>
</div>
<a id="a44654bac3cc1ee24b3e3d0ac7ab37a43" name="a44654bac3cc1ee24b3e3d0ac7ab37a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44654bac3cc1ee24b3e3d0ac7ab37a43">&#9670;&#160;</a></span>Matrix() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">linalg::Matrix::Matrix </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::initializer_list&lt; double &gt; &gt;</td>          <td class="paramname"><span class="paramname"><em>lst</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a matrix from a list of lists of doubles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">lst</td><td>The list of lists of doubles</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the lists of the list are not of equal size</td></tr>
  </table>
  </dd>
</dl>
<p>The function iterates over all sublists of the given list and checks if they are all of the same size. If not, it throws an exception. Otherwise, it allocates memory for the matrix and copies the elements of the sublists to the matrix. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5a6c4310332522a4dd8390503b5be464" name="a5a6c4310332522a4dd8390503b5be464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6c4310332522a4dd8390503b5be464">&#9670;&#160;</a></span>det()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double linalg::Matrix::det </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the determinant of the matrix. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is empty or not square</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the matrix</dd></dl>
<p>The function creates a temporary matrix to avoid modifying the original matrix. The determinant is calculated by multiplying the elements on the main diagonal of the matrix after Gaussian elimination. </p>

</div>
</div>
<a id="ab100afe2f2b7159627b52e12213c1e8b" name="ab100afe2f2b7159627b52e12213c1e8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab100afe2f2b7159627b52e12213c1e8b">&#9670;&#160;</a></span>Gauss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> linalg::Matrix::Gauss </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>rref</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gaussian elimination. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rref</td><td>If true, the result will be in reduced row echelon form (RREF) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of Gaussian elimination</dd></dl>
<p>The function performs Gaussian elimination on the matrix. If the parameter rref is true, the result will be in reduced row echelon form (RREF). </p>

</div>
</div>
<a id="a832a0695cdb27222279a019d70fb56c7" name="a832a0695cdb27222279a019d70fb56c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832a0695cdb27222279a019d70fb56c7">&#9670;&#160;</a></span>minor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double linalg::Matrix::minor </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>rows</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>columns</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the minor of the matrix at the given position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rows</td><td>The row of the minor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">columns</td><td>The column of the minor</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the position is outside of the matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The minor of the matrix</dd></dl>
<p>The minor is calculated by creating a temporary matrix that excludes the row and column of the given position. The determinant of this temporary matrix is then calculated and returned. </p>

</div>
</div>
<a id="ad230dd6657ebeac6eff624dc7d243849" name="ad230dd6657ebeac6eff624dc7d243849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad230dd6657ebeac6eff624dc7d243849">&#9670;&#160;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double linalg::Matrix::norm </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the norm of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The norm of the matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is empty</td></tr>
  </table>
  </dd>
</dl>
<p>The norm of a matrix is the square root of the sum of the squares of all elements. This method is const, as it does not modify the matrix. </p>

</div>
</div>
<a id="a3f8677399f619c7be88ba9e62ace30f3" name="a3f8677399f619c7be88ba9e62ace30f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8677399f619c7be88ba9e62ace30f3">&#9670;&#160;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double &amp; linalg::Matrix::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>column</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the element at the specified position in the matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>The row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>The column index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the element at the specified position</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the specified position is out of the matrix bounds</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides direct access to the element at the given row and column indices. It checks if the indices are within the matrix bounds and throws an exception if they are out of range. The function returns a reference, which allows modification of the element at the specified position. </p>

</div>
</div>
<a id="a301b619458307295d080f3d77a98fe5f" name="a301b619458307295d080f3d77a98fe5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301b619458307295d080f3d77a98fe5f">&#9670;&#160;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double &amp; linalg::Matrix::operator() </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>row</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>column</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accesses the element at the specified position in the matrix (const version) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">row</td><td>The row index </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>The column index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const reference to the element at the specified position</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::out_of_range</td><td>If the specified position is out of the matrix bounds</td></tr>
  </table>
  </dd>
</dl>
<p>This function provides read-only access to the element at the given row and column indices. It checks if the indices are within bounds and throws an exception if not. </p>

</div>
</div>
<a id="a63f26984333a74a464d6d31e5d6ef5d5" name="a63f26984333a74a464d6d31e5d6ef5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f26984333a74a464d6d31e5d6ef5d5">&#9670;&#160;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp; linalg::Matrix::operator*= </td>
          <td>(</td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales a matrix by a scalar. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">c</td><td>The scalar to scale by</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled matrix</dd></dl>
<p>The result is a new matrix that is the result of scaling the input matrix by the given scalar. The original matrix is not modified. </p>

</div>
</div>
<a id="ac6cad550f4d7ab094197e1f060faa82e" name="ac6cad550f4d7ab094197e1f060faa82e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6cad550f4d7ab094197e1f060faa82e">&#9670;&#160;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp; linalg::Matrix::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplies the matrix by another matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to multiply with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the resulting matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the number of columns of the current matrix is not equal to the number of rows of the matrix to multiply with</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs matrix multiplication. The resulting matrix will have the same number of rows as the current matrix and the same number of columns as the matrix being multiplied. The original matrix is replaced with the result. </p>

</div>
</div>
<a id="aaf33ca858d3b47ffd0adf964704427da" name="aaf33ca858d3b47ffd0adf964704427da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf33ca858d3b47ffd0adf964704427da">&#9670;&#160;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp; linalg::Matrix::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds another matrix to the current matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current matrix after addition</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the sizes of the matrices are not equal</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs element-wise addition of another matrix to the current matrix. It checks if the sizes of the matrices are equal, and throws an exception if not. The result replaces the original matrix. </p>

</div>
</div>
<a id="aaad68f42252b84c22242236d8c6c157b" name="aaad68f42252b84c22242236d8c6c157b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad68f42252b84c22242236d8c6c157b">&#9670;&#160;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp; linalg::Matrix::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtracts one matrix from another. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>The matrix to subtract from the current matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The result of the subtraction</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the sizes of the matrices are not equal</td></tr>
  </table>
  </dd>
</dl>
<p>This method subtracts the matrix m from the current matrix. It checks if the sizes of the matrices are equal, and throws an exception if not. Then it subtracts the elements of the matrix m from the current matrix. </p>

</div>
</div>
<a id="a47851fafac86b6455efcfb3fba322ec3" name="a47851fafac86b6455efcfb3fba322ec3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47851fafac86b6455efcfb3fba322ec3">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a> &amp; linalg::Matrix::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlinalg_1_1_matrix.html">Matrix</a></td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>The matrix to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the current matrix after assignment</dd></dl>
<p>This method implements the copy-swap idiom, which allows to use this operator as a move assignment operator as well. It swaps the contents of the current matrix with the contents of the other matrix, and then returns a reference to the current matrix. </p>

</div>
</div>
<a id="ab397cae560fbd57d351232dff61d07b9" name="ab397cae560fbd57d351232dff61d07b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab397cae560fbd57d351232dff61d07b9">&#9670;&#160;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double linalg::Matrix::trace </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the trace of the matrix. </p>
<dl class="section return"><dt>Returns</dt><dd>The trace of the matrix</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>If the matrix is empty or not square</td></tr>
  </table>
  </dd>
</dl>
<p>The trace of a matrix is the sum of the elements on the main diagonal. This method is const, as it does not modify the matrix. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/User/Desktop/AIP/lab1/lab1/linalg/include/<a class="el" href="matrix_8h_source.html">matrix.h</a></li>
<li>C:/Users/User/Desktop/AIP/lab1/lab1/linalg/source/<a class="el" href="matrix_8cpp.html">matrix.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0
</small></address>
</div><!-- doc-content -->
</body>
</html>
